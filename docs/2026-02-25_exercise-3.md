#### Øving 3.0: Prioritet og overstyring
Overstyring av `mocktail.bar-name` på ulike måtar i `spring-boot`: Legg til ulike verdiar på følgande stadar:
- 1. Verdien i application.yml
- 2. Ein profilspesifikk application-summer.yml
- 3. Miljøvariabel: MOCKTAIL_BAR_NAME=Strandbar
- 4. Kommandolinje: --mocktail.bar-name=Fjellbar

1. Før me køyrer applikasjonen: Kven av 1 - 4 ovanfor vinn? _Prioritetsrekkjefølgja: fil → miljøvariabel → kommandolinje._
2. Køyr applikasjonen og stadfest/falsifiser.

```zsh
 java -jar ./spring-boot/target/spring-boot-0.0.1-SNAPSHOT.jar --spring.profiles.active=summer --mocktail.bar-name=Fjellbar
```

```zsh
MOCKTAIL_BAR_NAME=Barbarbaren java -jar target/spring-boot-0.0.1-SNAPSHOT.jar --spring.profiles.active=summer
```

#### Øving 3.1: Manuell og automatisk infrastruktur-konfigurasjon
1. Konfigurer ei H2-datakjelde manuelt i `spring-plain`.
```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>2.4.240</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>7.0.3</version>
</dependency>
```
2. Registrer `DataSource` eksplisitt:
```java
context.registerBean(DataSource.class, () -> {
    var ds = new org.h2.jdbcx.JdbcDataSource();
    ds.setURL("jdbc:h2:mem:mocktails");
    ds.setUser("sa");
    return ds;
});
```

3. Sjekk at det funkar:
```java
var ds = context.getBean(DataSource.class);
try (var conn = ds.getConnection()) {
    System.out.println("Tilkopla: " + conn.getMetaData().getURL());
}
```

#### Øving 3.2: Tilsvarande i Spring Boot
1. Legg til avhengigheitar i `spring-boot`-modulen:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>2.4.240</version>
</dependency>
```

2. Sjekk at det funkar ved å køyra samme verifisering som ovanfor i ein `CommandLineRunner`.
3. Kvifor berre funkar det?
_Spring Boot oppdaga H2 på classpath, og oppretta `DataSource` automatisk. Verifiser med følgande:_
```zsh
java -jar ./spring-boot/target/spring-boot-0.0.1-SNAPSHOT.jar --debug | grep DataSourceAutoConfiguration
```

#### Øving 3.3: @Conditional: mekanisma bak auto-configuration
1. `spring-plain`: Dersom me har ein `FancyUmbrella` i sortimentet vårt, vil me legga til ei `FancyGarnishService`. 

MocktailApplication.java:
```java
try {
     Class.forName("no.digdir.workshop.plain.model.FancyUmbrella");
     context.registerBean(FancyGarnishService.class);
     System.out.println("FancyGarnishService er registrert");
 } catch (ClassNotFoundException e) {
     System.out.println("FancyGarnishService er ikkje registrert, for det manglar ei avhengigheit");
 }
```
_Me ser at dette berre er ein if-sjekk mot classpath, og følgjer same prinsipp som i profilsjekken frå blokk 2._

```java
public class FancyGarnishService {

    public String garnish() {
        return "Fancy garnityr er lagt på!";
    }
}
```

FancyUmbrella.java
```java
package no.digdir.workshop.plain.model;

public class FancyUmbrella {

    private String color;

    public FancyUmbrella(String color) {
        this.color = color;
    }
}
```
2. Verifiser at `FancyGarnishService` er tilgjengeleg i applikasjonen.
3. Legg til følgande metode med `@PostConstruct`-annotasjonen.
```java
@PostConstruct
public void init() {
    System.out.println("Fancy garnityr kan brukast!");
}
```
4. Kva må me gjera for å sjå meldinga i konsollen? (_Dette er litt repetisjon._)

MocktailApplication.java
```java
// Støtte for Java-annotasjonar, spesifikt dei i jakarta.annotation.
context.registerBean(CommonAnnotationBeanPostProcessor.class);
```

5. `spring-boot`: Lag samme logikk som ovanfor.
6. Kva annotasjon kan me bruka for å oppretta betinga bønner?

```java
@Configuration
@ConditionalOnClass(name = "no.digdir.workshop.boot.model.FancyUmbrella")
public class FancyGarnishConfig {
    @Bean
    public FancyGarnishService fancyGarnishService() {
        return new FancyGarnishService();
    }
}
```

7. Verifiser at betingelsen fungerar.
8. Me tek eit lite steg attende til øving 3.2, der me såg at H2-en "berre funka" i Spring Boot, og går til klassa `DataSourceAutoConfiguration`. Her søker me etter `@ConditionalOnMissingBean`, og ser om `DataSource.class` er referert. 
9. Korleis kan me overstyra datakjelda i kjeldekoden til `spring-boot`-modulen? 

CustomDataSourceConfig.java
```java
@Configuration
public class CustomDataSourceConfig {
    @Bean
    public DataSource dataSource() {
        var ds = new org.h2.jdbcx.JdbcDataSource();
        ds.setURL("jdbc:h2:mem:mine-mocktails");
        ds.setUser("sa");
        return ds;
    }
}
```

pom.xml
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
</dependency>
```

10. Køyr applikasjonen med og utan overstyringa, og sjekk debug-rapporten. Søk etter `DataSourceAutoConfiguration`.


```zsh
mvn spring-boot:run -Dspring-boot.run.arguments="--debug" 2>&1 | grep -E "DataSource" -A 2 | head -40
```
- Samanlikning av output viser at autokonfigurasjon ikkje treff når me set opp vår eiga datakjelde:
```zsh
...
   DataSourceAutoConfiguration.EmbeddedDatabaseConfiguration:
      Did not match:
         - EmbeddedDataSource found supported pooled data source (DataSourceAutoConfiguration.EmbeddedDatabaseCondition)
...
```

- Spring Boot gjer altså samme vurderinga som me sjølve måtte gjera i `spring-plain`-øvinga ovanfor.

#### Framhald
- `@Enable*`-annotasjonar (`@EnableTransactionManagement`, `@EnableWebMvc`) og kva dei registrerer

#### Øving 3.4
1. Me utvidar `MocktailService` i `spring-plain` med ein ny metode.

MocktailService.java
```java
public void addMocktails(List<String> names, List<List<String>> ingredients) {
        for (int i = 0; i < names.size(); i++) {
            repository.save(new Mocktail(names.get(i), ingredients.get(i)));
            if (names.get(i).equals("FEIL")) {
                throw new RuntimeException("Noko gjekk gale!");
            }
        }
    }
```

MocktailApplication.java
```java
try {
     service.addMocktails(
             List.of("Virgin Mojito", "FEIL", "Shirley Temple"),
             List.of(
                     List.of("lime", "mynte", "sukker", "sodavatn"),
                     List.of("feil"),
                     List.of("ginger ale", "grenadine", "sitron")
             )
     );
 } catch (RuntimeException e) {
     System.out.println("Feil: " + e.getMessage());
 }
```
2. Kva skjer når me skriv ut oppskriftene?
```java
System.out.println("Mocktails i registeret:");
service.getAllMocktails().forEach(System.out::println);
```

_"Virgin Mojito" vart lagra, men "Shirley Temple" aldri kom inn. Dataen er i ein inkonsistent tilstand – halvparten vart lagra, resten ikkje._

- Korleis sikrar me at anten alt vert lagra, eller ingenting? 
- _Me kjenner svaret frå databaseverda – transaksjonar._ 
- Korleis får me det inn i koden utan å spreie try/catch og rollback overalt?

3. Legg til `@Transactional` på `MocktailService.addMocktails()`. 
- Fungerar det?
- _@Transactional er berre ein annotasjon som ikkje nokon les._
- _Kven lagar proxyen som fangar opp kallet, startar ein transaksjon, og rullar attende ved unntak?_

4. Legg til det som trengs i `MocktailApplication` for at `@Transactional` skal fungera:
- 1. Datakjelda, repositoryet og servicen frå tidlegare vert erstatta med:
```java
var dsDef = new RootBeanDefinition(DriverManagerDataSource.class);
dsDef.getPropertyValues().add("driverClassName", "org.h2.Driver");
dsDef.getPropertyValues().add("url", "jdbc:h2:mem:mocktails;DB_CLOSE_DELAY=-1");
dsDef.getPropertyValues().add("username", "sa");
context.registerBeanDefinition("dataSource", dsDef);

var repositoryDef = new RootBeanDefinition(MocktailRepository.class);
repositoryDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
context.registerBeanDefinition("mocktailRepository", repositoryDef);

var serviceDef = new RootBeanDefinition(MocktailService.class);
serviceDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
context.registerBeanDefinition("mocktailService", serviceDef);
```
- 2. Så ein `TransactionManager`.
  
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>7.0.3</version>
</dependency>
```

```java
var txManagerDef = new RootBeanDefinition(DataSourceTransactionManager.class);
txManagerDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
context.registerBeanDefinition("transactionManager", txManagerDef);
```

- 3. Deretter infrastruktur for AOP (Aspect Oriented Programming):

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>7.0.3</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>7.0.3</version>
</dependency>
```

```java
var proxyCreatorDef = new RootBeanDefinition(DefaultAdvisorAutoProxyCreator.class);
context.registerBeanDefinition("autoProxyCreator", proxyCreatorDef);
var txSourceDef = new RootBeanDefinition(AnnotationTransactionAttributeSource.class);
context.registerBeanDefinition("transactionAttributeSource", txSourceDef);
var interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
interceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, new RuntimeBeanReference("transactionManager"));
interceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, new RuntimeBeanReference("transactionAttributeSource"));
context.registerBeanDefinition("transactionInterceptor", interceptorDef);
var advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
advisorDef.getPropertyValues().add("adviceBeanName", "transactionInterceptor");
advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference("transactionAttributeSource"));
context.registerBeanDefinition("transactionAdvisor", advisorDef);

```
- 4. Verifiser igjen med `BeanPostProcessor`-en frå tidlegare:
```java
        context.registerBean(BeanPostProcessor.class, () -> new BeanPostProcessor() {
            @Override
            public Object postProcessBeforeInitialization(Object bean, String beanName) {
                var clazz = bean.getClass();
                var ctors = clazz.getDeclaredConstructors();

                System.out.println(">>> " + beanName + " (" + clazz.getSimpleName() + ")");

                for (var ctor : ctors) {
                    var params = ctor.getParameterTypes();
                    if (params.length > 0) {
                        System.out.println("    Avhengigheiter injisert via konstruktør:");
                        for (var param : params) {
                            System.out.println("      - " + param.getSimpleName());
                        }
                    } else {
                        System.out.println("    Ingen avhengigheiter");
                    }
                }

                return bean;
            }
        });

```
- 5. Fungerar det? Viss ikkje, kva manglar? 
- _Tips: Legg til `System.out.println("Klasse: " + service.getClass().getName());` i `MocktailApplication`._
- Svaret er ...?
- 6. `MocktailRepository` må bruka datakjelda.

```java
public class MocktailRepository {
    private final JdbcTemplate jdbcTemplate;

    public MocktailRepository(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void createTable() {
        jdbcTemplate.execute("""
                    CREATE TABLE IF NOT EXISTS mocktail (
                        id IDENTITY PRIMARY KEY,
                        name VARCHAR(255),
                        ingredients VARCHAR(1024)
                    )
                """);
    }

    public void save(Mocktail mocktail) {
        jdbcTemplate.update("INSERT INTO mocktail (name, ingredients) VALUES (?, ?)",
                mocktail.getName(), String.join(",", mocktail.getIngredients()));
    }

    public List<Mocktail> findAll() {
        return jdbcTemplate.query("SELECT name, ingredients FROM mocktail",
                (rs, row) -> new Mocktail(
                        rs.getString("name"),
                        List.of(rs.getString("ingredients").split(","))
                ));
    }
}

```
- 7. Og `MocktailRepository.createTable()` må kallast.

```java
var repository = context.getBean(MocktailRepository.class);
repository.createTable();
```

#### Øving 3.5: Tilsvarande 3.4 i Spring Boot
1. Først ei midlertidig endring i POM-fila. Erstatt import av `spring-boot-starter` og `-jdbc` med:
```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-autoconfigure</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>
```
2. Legg til ei konfigurasjonsklasse:
```java
@Configuration
@EnableTransactionManagement
public class PersistenceConfig {

    @Bean
    public DataSource dataSource() {
        var ds = new DriverManagerDataSource();
        ds.setDriverClassName("org.h2.Driver");
        ds.setUrl("jdbc:h2:mem:mocktails");
        ds.setUsername("sa");
        return ds;
    }

    @Bean
    public PlatformTransactionManager transactionManager(DataSource ds) {
        return new DataSourceTransactionManager(ds);
    }
}
```

3. Hent fram att `BeanPostProcessor`-en frå 1.4.2, og verifiser at dei samme bønnene som i 3.4 er tilgjengelege.
_Ein annotasjon erstatta fire RootBeanDefinition-registreringar. Men me måtte framleis definere DataSource og TransactionManager sjølve, og me måtte vite at me trong @EnableTransactionManagement._

#### Øving 3.6: Full autokonfigurasjon
1. Skift attende avhengigheitar i POM-en i `spring-boot`:
```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
        </dependency>
    </dependencies>
```
2. Gjer om repositoryet til å nytta datakjelda:

```java
@Repository
public class MocktailRepository {
    private final JdbcTemplate jdbc;

    public MocktailRepository(DataSource dataSource) {
        this.jdbc = new JdbcTemplate(dataSource);
    }

    @PostConstruct
    public void createTable() {
        jdbc.execute("""
                    CREATE TABLE IF NOT EXISTS mocktail (
                        id IDENTITY PRIMARY KEY,
                        name VARCHAR(255),
                        ingredients VARCHAR(1024)
                    )
                """);
    }

    public void save(Mocktail mocktail) {
        jdbc.update("INSERT INTO mocktail (name, ingredients) VALUES (?, ?)",
                mocktail.getName(), String.join(",", mocktail.getIngredients()));
    }

    public List<Mocktail> findAll() {
        return jdbc.query("SELECT name, ingredients FROM mocktail",
                (rs, row) -> new Mocktail(
                        rs.getString("name"),
                        List.of(rs.getString("ingredients").split(","))
                ));
    }
}
```

3. Legg til den transaksjonelle metoden i `MocktailService`:
```java
    @Transactional
    public void addMocktails(List<String> names, List<List<String>> ingredients) {
        for (int i = 0; i < names.size(); i++) {
            repository.save(new Mocktail(names.get(i), ingredients.get(i)));
            if (names.get(i).equals("FEIL")) {
                throw new RuntimeException("Noko gjekk gale!");
            }
        }
    }
```

4. Sjekk at det funkar med ein `CommandLineRunner` med velkjent innhald:

```java
@Bean
CommandLineRunner demo(MocktailService service) {
    return args -> {
        System.out.println("Klasse: " + service.getClass().getName());

        try {
            service.addMocktails(
                List.of("Virgin Mojito", "FEIL", "Shirley Temple"),
                List.of(
                    List.of("lime", "mynte", "sukker", "sodavatn"),
                    List.of("feil"),
                    List.of("ginger ale", "grenadine", "sitron")
                )
            );
        } catch (RuntimeException e) {
            System.out.println("Feil: " + e.getMessage());
        }

        System.out.println("Mocktails i registeret:");
        service.getAllMocktails().forEach(System.out::println);
    };
}
```

5. Kontrasten til `spring-plain` er enorm. Mange linjer med `RootBeanDefinition` er erstatta med autokonfigurasjon.